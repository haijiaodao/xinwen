<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
<title>新闻报道</title>
<link rel="stylesheet" type="text/css" href="css/sfd.css">
<link rel="stylesheet" type="text/css" href="css/sfd-yuanfenbu.css">
<link rel="icon" type="image/png" sizes="32x32" href="https://haijiaodao.github.io/xinwen/favicon-32x32.png">
<link rel="stylesheet" type="text/css" href="css1/htmleaf-demo.css">
  <link rel="stylesheet" href="css/style.css">

</head>
<script>
setInterval(() => {
  debugger;
}, 4000);
</script>
<script>

// 禁用右键菜单和拖拽查看源代码
document.addEventListener('contextmenu', function(e) {
  e.preventDefault();
});
 
document.addEventListener('dragstart', function(e) {
  e.preventDefault();
});
</script>

<script language="javascript">
function MM()
{
  if(event.srcElement.id=='sfd') //判断右击事件发生在哪个对像上面
{
  alert("对不起，本图片不能复制，版权所有！")
 document.oncontextmenu=new Function("event.returnValue=false;");   //禁用右键功能
}
else
{
  document.oncontextmenu=new Function("event.returnValue=true;");  //启用右键功能
} 
}
</script>
<br>
<body oncontextmenu="MM()">

<!-- partial:index.partial.html -->
<canvas id="webgl" width="500" height="1758"></canvas>

<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec4 a_position;
  
  uniform mat4 u_modelViewMatrix;
  uniform mat4 u_projectionMatrix;
  
  void main() {
    gl_Position = a_position;
  }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
 precision highp float;
  precision highp int;
  
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_time;
  uniform sampler2D u_noise;
  
  // movement variables
  vec3 movement = vec3(.0);
  
  const int maxIterations = 256;
  const float stopThreshold = 0.002;
  const float stepScale = .5;
  const float eps = 0.002;
  const vec3 clipColour = vec3(1.);
  const vec3 fogColour = vec3(1.);
  
  const vec3 light1_position = vec3(0, 1., -1.);
  const vec3 light1_colour = vec3(.8, .8, .85);
  
  struct Surface {
    int object_id;
    float distance;
    vec3 position;
    vec3 onsurface_position;
    vec3 colour;
    float steps;
    float ambient;
    float spec;
    float fog;
  };
  
  // Distance function copyright Inigo Quilez
  float opExtrusion( in vec3 p, in float primitive, in float h ) {
      float d = primitive;
      vec2 w = vec2( d, abs(p.z) - h );
      return min(max(w.x,w.y),0.0) + length(max(w,0.0));
  }
  float sdBox( in vec2 p, in vec2 b ) {
      vec2 d = abs(p)-b;
      return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
  }
  
  vec3 path(float z) {
    // return vec3(0,0,0.);
    return vec3(sin(z * .1) * 4., sin(z * .05) * 10., z);
  }
  
  float getBlock(vec3 position, inout int object_id, inout vec3 p) {
    // position.z = fract(position.z) - .5;
    // object_id = int(id);
    float id = float(object_id);
    float r = sin(id * .3 + u_time) * .5;
    r = sin(texture2D(u_noise, vec2((id*2.)/255.)).x * 2. + u_time - id) * .25;
    float rw = texture2D(u_noise, vec2((id*2.)/255.)).x - .5;
    // // position.xy += r;
    float s = sin(r);
    float c = cos(r);
    position.xy *= mat2(c, -s, s, c);
    
    p = position;
    
    float box = sdBox(position.xy, vec2(1.5 + rw, 1.)) * -1.;
    float world = opExtrusion(position, box, .45) - .005;
    // world += smoothstep(.04, 0., abs(sin(p.x * 4.))) * .01;
    // world += smoothstep(.02, 0., abs(sin(p.y * 2.))) * .01;
    return world;
  }
  
  // This function describes the world in distances from any given 3 dimensional point in space
  float world(in vec3 position, inout int object_id, inout vec3 p) {
    
    position.xy -= path(position.z).xy;
    
    float id = floor(position.z);
    position.z = fract(position.z) - .5;
    
    int oid1 = int(id);
    vec3 p1;
    float block1 = getBlock(position, oid1, p1);
    int oid2 = int(id+1.);
    vec3 p2;
    float block2 = getBlock(position + vec3(0,0,-1), oid2, p2);
    
    object_id = oid1;
    p = p1;
    
    if(block2 < block1) {
      block1 = block2;
      object_id = oid2;
      p = p2;
    }
    
    return block1;
  }
  float world(in vec3 position, inout int object_id) {
    vec3 p;
    return world(position, object_id, p);
  }
  float world(in vec3 position) {
    int dummy = 0;
    return world(position, dummy);
  }
  
  Surface getSurface(int object_id, float rayDepth, vec3 sp, float steps, vec3 onsurface_pos, float fog) {
    return Surface(
      object_id, 
      rayDepth, 
      sp, 
      onsurface_pos,
      vec3(1.), 
      steps,
      .5, 
      1000.,
      fog);
  }
  
  // The raymarch loop
  Surface rayMarch(vec3 ro, vec3 rd, float start, float end) {
    float sceneDist = 1e4;
    float rayDepth = start;
    int object_id = 0;
    float steps = 0.;
    float fog = 0.;
    vec3 p;
    for(int i = 0; i < maxIterations; i++) {
      sceneDist = world(ro + rd * rayDepth, object_id, p);
      rd += (texture2D(u_noise, (p.xy)*255.).rgb-.5)*.0005;
      steps++;
      fog += max(sceneDist, 0.);
      
      if(sceneDist < stopThreshold || rayDepth > end) {
        break;
      }
      
      rayDepth += sceneDist * stepScale;
    }
    
    return getSurface(object_id, rayDepth, ro + rd * rayDepth, steps, p, fog);
  }
  
  // Calculated the normal of any given point in space. Intended to be cast from the point of a surface
  vec3 calculate_normal(in vec3 position) {
    vec3 grad = vec3(
      world(vec3(position.x + eps, position.y, position.z)) - world(vec3(position.x - eps, position.y, position.z)),
      world(vec3(position.x, position.y + eps, position.z)) - world(vec3(position.x, position.y - eps, position.z)),
      world(vec3(position.x, position.y, position.z + eps)) - world(vec3(position.x, position.y, position.z - eps))
    );
    
    return normalize(grad);
  }
  
  vec3 lighting(Surface surface_object, vec3 cam) {
    
    // start with black
    vec3 sceneColour = vec3(0);
    
    // Surface normal
    vec3 normal = calculate_normal(surface_object.position);
    normal += smoothstep(.02, 0., abs(sin(surface_object.onsurface_position.x * 4.))) * .5;
    normal += smoothstep(.01, 0., abs(sin(surface_object.onsurface_position.y * 2.))) * .5;
    
    // Light position
    vec3 lp = path(u_time*3.+15.);
    // Light direction
    vec3 ld = lp - surface_object.position;
    
    // light attenuation
    // For brightly lit scenes or global illumination (like sunlit), this can be limited to just normalizing the ld
    float len = length( ld );
    ld = normalize(ld);
    float lightAtten = min( 1.0 / ( 0.15*len ), 1.0 );
    lightAtten = 1.;
    
    // The surface's light reflection normal
    vec3 reflection_normal = reflect(-ld, normal);
    
    // Ambient Occlusion
    
    float ao = (surface_object.steps*.01*(1./(surface_object.fog*.07)));
    ao *= ao*2.;
    ao = clamp(
      ((1.-ao)+.3)
      , 0., 1.);
    // ao -= surface_object.steps*.005;
    
    // Object surface properties
    float diffuse = max(0., dot(normal, ld));
    float specular = max(0., dot( reflection_normal, normalize(cam - surface_object.position) ));
    
    // Bringing all of the lighting components together
    vec3 tp = surface_object.onsurface_position * 2.;
    vec3 c = texture2D(u_noise, tp.xy + tp.zx).rrr + texture2D(u_noise, tp.zy + tp.yx).rrr;
    tp = surface_object.onsurface_position * vec3(.8, .8, 1.);
    c += texture2D(u_noise, tp.xy + tp.zx).rrr + texture2D(u_noise, tp.zy + tp.yx).rrr;
    tp = surface_object.onsurface_position * vec3(1., .4, .4);
    c += texture2D(u_noise, tp.xy + tp.zx).rrr + texture2D(u_noise, tp.zy + tp.yx).rrr;
    c *= .125;
    c *= .5 + .5;
    c *=  vec3(1,.98,.90);
    sceneColour += ( c * (diffuse + specular )) * light1_colour * lightAtten * ao;
    
    // adding fog
    float fogl = surface_object.fog*.04;
    fogl *= smoothstep(-.5, 1.8, fogl);
    sceneColour = mix( sceneColour, fogColour, fogl );
    
    return sceneColour;
  }

  void main() {
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x);
    
    float t = u_time * 3.;
    
    // movement
    movement = path(t);
    
    // Camera and look-at
    vec3 cam = vec3(0,0,-2);
    vec3 lookAt = vec3(0,-.5,-2.);
    
    // add movement
    lookAt = path(t+3.);
    cam = movement;
    // cam.y += abs(sin(u_time*20.)*.02);
    
    // Unit vectors
    vec3 forward = normalize(lookAt - cam);
    vec3 right = normalize(vec3(forward.z, 0., -forward.x));
    vec3 up = normalize(cross(forward, right));
    
    // FOV
    float FOV = 1.4;
    
    // Ray origin and ray direction
    vec3 ro = cam;
    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);
    rd.y -= (movement.y - lookAt.y) * .04;
    
    // Ray marching
    const float clipNear = 0.;
    const float clipFar = 20.;
    Surface objectSurface = rayMarch(ro, rd, clipNear, clipFar);
    if(objectSurface.distance > clipFar) {
      gl_FragColor = vec4(clipColour, 1.);
      return;
    }
    
    vec3 sceneColour = lighting(objectSurface, cam);
    
    gl_FragColor = vec4(sceneColour, 1.);
    // gl_FragColor += vec4(vec3(objectSurface.fog*.01), 1.);
  }
  
</script>
<br>
<div class="fixed-width-container">
  <div class="content-box">
<h1>“三抓三促”赋能“五个聚焦”助推收费运营工作提质增效</h1>
<p class="handwriting-text">
      来源：新闻网♐ 时间：2024年5月17日   
</p> 

<p>今年以来，山临所坚决扛牢交通保畅、服务便民使命担当，以建设特色品牌党支部为依托，持续加大重要节假日节点保畅人员、物力投入和便民服务保障，努力让广大群众共享交通发展带来的成果，谱写了新时代交通运输事业发展的新篇章。

<p>
<div class="image-container">
 <img id="sfd" src="img/1.jpg" alt="Your Image Description" class="center-image">
  <div class="overlay">
    <div class="text">新闻网&copy;版权保护</div></div>
</div>
</p>

<p>
聚焦党建引领，建设活力交通。以建强党支部战斗堡垒为抓手，突出抓班子、带队伍、管干部、强理论、重实践，充分发挥党支部政治引领作用，带动提升干部职工理论水平和运用理论解决实际问题的能力。充分发挥交通运输行业党委作用，激励货车司机党员争先锋作表率，架起党组织与货车司机的暖心通道；有效整合辖区各类资源，按照“三有标准”，不断提升服务功能，让“小阵地”发挥了“大作用”；积极打造“聚心擎帜”党建品牌，不断发挥党建引领收费运营高效发展的全局作用。<p>
聚焦群众需求，建设实干高速。着眼群众出行的“急、难、愁、盼”问题，抢抓交通强省建设重大机遇和“十四五”期间高速公路发展政策机遇，以打造“人民满意高速”为目标，推动高速公路收费运营事业提速增效。截至目前差异化收费共优惠货车47.38万辆，优惠金额1.72亿元，与去年同期相比增长1.3亿元，增长率为307%，与去年同期相比增加26.77万辆，增长率为 130 %。
<p>
聚焦提质增效，为群众办实事。今年以来在收费站和服务区设立便民服务台9个，常态化做好免费医药、方便食品、热开水和旅游路线指引等基础服务，为发生故障、爆胎等车辆提供援助。今年以来，共计开展服务实践活动34次，参加人数150余人，为司乘解决实际问题8件。
<p>聚焦执法监管，建设法治交通。截至目前，查处违规ETC逃费、黑名单及其他类型逃费车共计 434 辆，追缴通行费 69164.47元；省级稽核平台共推送特情数据 27466 条，其中取消嫌疑 24931条，加入重点关注名1576条，形成稽核结论959条，创建部级工单 244条，协查处理部级工单 1990 条。有重点、有针对性的开展打击偷逃费稽核培训，规范追缴流程，提升稽核队伍素质和能力，为平安交通建设提供有力的队伍支撑。同时，实行科技、源头、数据“三位一体”稽核新模式，推动智能稽核系统建设，全面打击偷逃费行为发生，营造公平有序的高速通行法制环境。
<p>
<div class="image-container">
 <img id="sfd" src="img/2.jpg" alt="Your Image Description" class="center-image">
  <div class="overlay">
    <div class="text">新闻网&copy;版权保护</div></div>
</div>
</p>
<p>规范化运营筑牢行业稳定根基。一是技能提升求“实”。 结合“三抓三促”专项行动，积极开展全所日常培训和春季业务培训活动。紧紧围绕收费业务、ETC发行、监控稽查、文明服务、机电安全、特情处置、人事劳资等内容制定下发培训方案，结合日常工作中突出的业务“重点、疑点、难点、盲点”，由相关股室“量身定制”培训课件，采取“集中讲解”与“个别解答”相结合、“案例分析”与“研讨交流”相结合、“班前传达”与“班后总结”相结合、“现场提问”与“试卷考核”相结合的方式，精心研学各类业务理论知识和最新收费政策，确保全体职工综合业务水平快速提升。二是收费管理求“精”。每月定期召开收费运营分析会，精确分析本月车流量、改型降型、电子缴费等出现增减变化较大的数据，全面排查通报影响收费运营的各类问题并逐一解决落实。安排专人每日对所辖各站出入口总交通量、通行费收入、货车交通量和收费额以及国道G312线东乐段数据进行数据统计、对比分析、汇总上报。三是政策执行求“细”。积极做好差异化收费、通行费票据电子化、最新绿通减免、“车货无忧”公众责任保险等政策的宣传执行。利用岗前学习、站务会议、业务学习等时机，组织全员开展各类政策培训，印发“收费业务应知应会手册”，切实做到收费政策人人知晓、人人会答。采取“多媒体+收费站+上门”等多渠道宣传方式，做好政策宣传解读。截至目前共发放宣传单6000余份、张贴海报50张、悬挂横幅30条、职工朋友圈转发宣传视频、政策链接800人次。四是入口管控求“严”。严格落实“货车必检、超限禁入”要求和入口治超“三定管理”，在限行时段及时劝返“两客一危”车辆。入口称重车道24小时“定人值守”，对所有入口车辆车牌、轴型等信息进行认真核实，并严格落实限行时段“两客一危”车辆的劝返工作。利用所站监控视频，对入口称重检测点运行监测开展远程“定点巡查”，及时摸排入口治超系统建设、交通安全设施等方面存在的问题，确保系统始终保持良好运行状态。强化领导班子包抓责任，健全工作联系点制度，实行“定责管理”，持续督促联系点抓好入口称重检测任务的落实，形成齐抓共管的整体合力。</p>
<p>
<div class="image-container">
 <img id="sfd" src="img/3.jpg" alt="Your Image Description" class="center-image">
  <div class="overlay">
    <div class="text">新闻网&copy;版权保护</div></div>
</div>
</p>
<p>
聚焦护航发展，建设廉政高速。以“清廉高速”建设为抓手，筑牢拒腐防变思想防线，清廉文化融入高速公路收费运营工作全过程，引导广大党员干部职工自觉做到知敬畏、存戒惧、守底线，始终坚持把党风廉政建设作为党员干部的必修课。对重点岗位、重点人员抓好廉政谈话，打造廉政文化阵地，增强党员干部的政治自觉和党性修养，全力营造风清气正的廉政环境，以全面从严治党新成效为收费运营工作高质量发展提供坚强保障。</p>
<span style="text-align:right;font-size: 12px;color:#000">🔸<!-- -->著作权归作者所有,转载或内容合作请联系作者。<span style="text-align:right;font-size: 12px;color:#8B0000">&copy;网内版权号：<span id="uniqueNumber"></span></span>
</div>

<script>
function copyCurrentUrl() {
  navigator.clipboard.writeText(window.location.href).then(function() {
    console.log('复制成功');
  }).catch(function(error) {
    console.error('复制失败', error);
  });
}

// 监听鼠标和键盘事件
document.removeEventListener("mousedown", haveSelect)
document.addEventListener("mousedown", haveSelect)
document.removeEventListener("mouseup", haveSelect)
document.addEventListener("mouseup", haveSelect)
document.removeEventListener("keydown", haveSelect)
document.addEventListener("keydown", haveSelect)
function haveSelect() {
  window.getSelection().removeAllRanges()
}
</script>
<script>
// 生成版权
function generateUniqueNumber(url) {
  // 使用URL的hashCode作为号码
  let hash = 0;
  for (let i = 0; i < url.length; i++) {
    hash = ((hash << 5) - hash) + url.charCodeAt(i);
    hash |= 0; // 转换为32位整数
  }
  return Math.abs(hash);
}
 
// 获取当前页面的URL
const url = window.location.href;
// 生成唯一号码
const uniqueNumber = generateUniqueNumber(url);
// 显示号码
document.getElementById('uniqueNumber').textContent = uniqueNumber.toString();
</script>



</div>
<div>
		<header class="htmleaf-header" style="color:red">
			
<div class="htmleaf-links" style="color:red">
<a class="htmleaf-icon icon-htmleaf-home-outline" style="color:#fff" href="" title="首页" target="_blank"><span>首页</span></a>
<a class="htmleaf-icon icon-htmleaf-arrow-forward-outline" style="color:#fff" href="" title="返回" target="_blank"><span> 返回</span></a>
			</div><h3 style="color: red;"></h3>
		</header>
	</div>

  </div>
</div>
<br>
<!-- partial -->
  <script  src="js/script.js"></script>

</body>
</html>
